<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="进程 &amp; 线程进程进程控制块：（PCB）描述进程基本情况和运行状态进程存在唯一标志 进程映像(进程实体)：程序段、相关数据段、PCB 进程：进程实体的运行过程，系统进行资源分配和调度的一个独立单位 进程特征：  动态性(最重要特点) 并发性 独立性 异步性 结构性  进程状态 &amp; 转换基本状态：运行态、就绪态、阻塞态  运行态：进程在处理机上运行 就绪态：进程获得了除处理机外所有资">
<meta property="og:type" content="article">
<meta property="og:title" content="进程管理">
<meta property="og:url" content="http://example.com/2022/07/13/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Jarrycow">
<meta property="og:description" content="进程 &amp; 线程进程进程控制块：（PCB）描述进程基本情况和运行状态进程存在唯一标志 进程映像(进程实体)：程序段、相关数据段、PCB 进程：进程实体的运行过程，系统进行资源分配和调度的一个独立单位 进程特征：  动态性(最重要特点) 并发性 独立性 异步性 结构性  进程状态 &amp; 转换基本状态：运行态、就绪态、阻塞态  运行态：进程在处理机上运行 就绪态：进程获得了除处理机外所有资">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/E296C0365BA348F6B7B0D610D5BC6AD2/69245">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/F1E7DC5BA8BF48AE8D8C9132C055A29B/69247">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/17461E55F69F4857B613B82517EC6DBE/69249">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/D09E471082B9482181CAD659D941DF79/69251">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/7BBF531D0FF0499F86A89A0B88A510FA/70056">
<meta property="og:image" content="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/2048548B0AD345519DEA55DA6B6803AC/70058">
<meta property="article:published_time" content="2022-07-13T08:44:14.000Z">
<meta property="article:modified_time" content="2022-07-21T02:04:16.738Z">
<meta property="article:author" content="Jarrycow">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/E296C0365BA348F6B7B0D610D5BC6AD2/69245">

<link rel="canonical" href="http://example.com/2022/07/13/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>进程管理 | Jarrycow</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jarrycow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-friend">

    <a href="/friend/" rel="section"><i class="fa-heart fa-fw"></i>友链</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/13/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jarrycow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jarrycow">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          进程管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-13 16:44:14" itemprop="dateCreated datePublished" datetime="2022-07-13T16:44:14+08:00">2022-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-21 10:04:16" itemprop="dateModified" datetime="2022-07-21T10:04:16+08:00">2022-07-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程 &amp; 线程"></a>进程 &amp; 线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程控制块：</strong>（PCB）描述进程基本情况和运行状态<sub>进程存在唯一标志</sub></p>
<p><strong>进程映像(进程实体)：</strong>程序段、相关数据段、PCB</p>
<p><strong>进程：</strong>进程实体的运行过程，系统进行资源分配和调度的一个独立单位</p>
<p><strong>进程特征：</strong></p>
<ul>
<li>动态性(最重要特点)</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
<li>结构性</li>
</ul>
<h3 id="进程状态-amp-转换"><a href="#进程状态-amp-转换" class="headerlink" title="进程状态 &amp; 转换"></a>进程状态 &amp; 转换</h3><p><strong>基本状态：</strong>运行态、就绪态、阻塞态</p>
<ul>
<li><strong>运行态：</strong>进程在处理机上运行</li>
<li><strong>就绪态：</strong>进程获得了除处理机外所有资源，得到处理机立即运行<sub>排成队列</sub></li>
<li><strong>阻塞态：</strong>等待某事件暂停运行<sub>资源、I/O</sub></li>
<li><strong>创建态：</strong>进程正在被创建</li>
<li><strong>结束态：</strong>进程从系统消失</li>
</ul>
<p><img src="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/E296C0365BA348F6B7B0D610D5BC6AD2/69245"></p>
<ul>
<li><strong>就绪态$\rightarrow$运行态：</strong>获得处理机资源<sub>分派处理机时间片</sub></li>
<li><strong>运行态$\rightarrow$就绪态：</strong>时间片用完/更高优先级进程就绪</li>
<li><strong>运行态$\rightarrow$阻塞态：</strong>进程请求资源或等待某一事件</li>
<li><strong>阻塞态$\rightarrow$就绪态：</strong>进程等待事件到来</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><ol>
<li><p><strong>进程创建</strong></p>
<ol>
<li><p>为新进程分配一个唯一<strong>进程标识号</strong>，申请一个<strong>空白PCB</strong></p>
</li>
<li><p>为进程<strong>分配资源</strong>，为新进程的程序和数据及用户栈分配必要的<strong>内存空间</strong><sub>PCB中体现</sub></p>
<p>若资源不足，则处于阻塞态，等待内存资源</p>
</li>
<li><p><strong>初始化 PCB</strong><sub>标志信息、处理机状态信息、处理机控制信息、进程优先级</sub></p>
</li>
<li><p>若进程就绪队列能够接纳新进程，则<strong>插入就绪队列</strong>，等待被调度运行</p>
</li>
</ol>
</li>
<li><p><strong>进程终止</strong></p>
<ul>
<li><strong>引起</strong><ul>
<li>正常结束</li>
<li>异常结束</li>
<li>外界干预</li>
</ul>
</li>
<li><strong>撤销原语过程</strong><ol>
<li>根据被终止进程的标识符，<strong>检索PCB</strong>，读取进程状态</li>
<li>若处于运行态，<strong>立即终止该进程</strong></li>
<li>若该进程还有子孙进程，终止所有子孙进程</li>
<li><strong>将该进程所有资源归还</strong>父进程或操作系统</li>
<li>将该<strong>PCB从所在队列删除</strong></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>进程阻塞 &amp; 唤醒</strong></p>
<p><strong>阻塞原语过程：</strong></p>
<ol>
<li>根据被阻塞进程的标识符，<strong>检索PCB</strong>，读取进程状态</li>
<li>若处于运行态，保护现场，<strong>转为阻塞态</strong>，停止运行</li>
<li>把该<strong>PCB插入相应事件等待队列</strong></li>
</ol>
<p><strong>唤醒原语过程：</strong></p>
<ol>
<li>根据被阻塞进程的标识符，<strong>检索PCB</strong></li>
<li>将其从等待队列中移出，<strong>转为就绪态</strong></li>
<li>把该<strong>PCB插入就绪队列</strong>，等待调度程序调度</li>
</ol>
</li>
<li><p><strong>进程切换</strong></p>
<ol>
<li><strong>保存</strong>处理机上下文<sub>程序计数器、其他寄存器</sub></li>
<li><strong>更新PCB</strong>信息</li>
<li>进程<strong>PCB移入相应的队列</strong></li>
<li>选择另一个<strong>进程执行</strong>，更新其PCB</li>
<li><strong>更新内存</strong>管理的数据结构</li>
<li><strong>恢复</strong>处理机上下文</li>
</ol>
</li>
</ol>
<h3 id="进程组织"><a href="#进程组织" class="headerlink" title="进程组织"></a>进程组织</h3><p><strong>进程控制块PCB</strong>（核心）</p>
<table>
<thead>
<tr>
<th>进程描述信息</th>
<th>进程控制和管理信息</th>
<th>资源分配清单</th>
<th>处理机相关信息</th>
</tr>
</thead>
<tbody><tr>
<td>进程标识符PID</td>
<td>进程当前状态</td>
<td>代码段指针</td>
<td>通用寄存器值</td>
</tr>
<tr>
<td>用户标识符UID</td>
<td>进程优先级</td>
<td>数据段指针</td>
<td>地址寄存器值</td>
</tr>
<tr>
<td></td>
<td>代码运行入口地址</td>
<td>堆栈段指针</td>
<td>控制寄存器值</td>
</tr>
<tr>
<td></td>
<td>程序的外存地址</td>
<td>文件描述符</td>
<td>标志寄存器值</td>
</tr>
<tr>
<td></td>
<td>进入内存时间</td>
<td>键盘</td>
<td>状态字</td>
</tr>
<tr>
<td></td>
<td>处理机占用时间</td>
<td>鼠标</td>
<td></td>
</tr>
<tr>
<td></td>
<td>信号量使用</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>进程描述信息</strong></p>
<ul>
<li>进程标识符PID：标志各进程，每个进程有唯一标识号</li>
<li>用户标识符UID：进程归属用户，为共享和保护服务</li>
</ul>
</li>
<li><p><strong>进程控制和管理信息</strong></p>
<ul>
<li>进程当前状态：描述进程状态，作为处理机分配调度依据</li>
<li>进程优先级：描述进程抢占处理机的优先级</li>
</ul>
</li>
<li><p><strong>资源分配清单</strong></p>
<p>说明有关内存地址和虚拟地址状况，所打开文件列表和I/O信息</p>
</li>
<li><p><strong>处理机相关信息</strong></p>
<p>处理集中各寄存器值<sub>进程切换保存</sub></p>
</li>
</ul>
<p><strong>程序段</strong></p>
<p>被进程调度到CPU执行代码段</p>
<p><strong>数据段</strong></p>
<p>进程程序处理的数据</p>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程之间信息交换</p>
<p><strong>共享存储</strong></p>
<p>进程之间存在一块可<strong>直接访问</strong>的共享空间，通过对共享空间读写进行通信</p>
<p><img src="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/F1E7DC5BA8BF48AE8D8C9132C055A29B/69247"></p>
<p>需要<strong>同步互斥</strong>，必须通过<strong>系统调用</strong>实现</p>
<p><strong>消息传递</strong></p>
<p>以<strong>格式化消息</strong>为单位</p>
<ul>
<li>直接通信方式</li>
<li>间接通信方式<sub>邮件</sub></li>
</ul>
<p><img src="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/17461E55F69F4857B613B82517EC6DBE/69249"></p>
<p><strong>管道通信</strong></p>
<p><img src="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/D09E471082B9482181CAD659D941DF79/69251"></p>
<p>连接一个读进程和一个写进程</p>
<p><strong>提供协调能力：</strong>互斥、同步、确定对方存在</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>基本的CPU执行单元<sub>线程ID、程序计数器、寄存器集合、堆栈</sub><br>进程一个实体，被系统独立调度的基本单位</p>
<h3 id="线程-amp-进程"><a href="#线程-amp-进程" class="headerlink" title="线程 &amp; 进程"></a>线程 &amp; 进程</h3><p><strong>调度：</strong></p>
<ul>
<li><p>线程是独立调度的基本单位</p>
</li>
<li><p>同一进程中线程切换不会引起进程切换</p>
<p>不同进程中线程切换会引起进程切换</p>
</li>
</ul>
<p><strong>资源：</strong></p>
<ul>
<li>进程是拥有资源的基本单位</li>
<li>线程不拥有系统资源</li>
</ul>
<p><strong>并发性：</strong>均可并发执行</p>
<p><strong>系统开销：</strong>进程开销远大于线程开销</p>
<p><strong>地址空间和其他资源：</strong></p>
<ul>
<li>进程地址空间相互独立</li>
<li>同一进程各线程共享资源</li>
</ul>
<p><strong>通信：</strong></p>
<ul>
<li>进程通信需进程同步和互斥辅助</li>
<li>线程通信直接读写进程数据段</li>
</ul>
<h3 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h3><ul>
<li>不拥有系统资源，但每个线程都有一个唯一的标识符和一个线程控制块</li>
<li>不同的线程可以执行相同的程序</li>
<li>同一进程中各个线程共享该进程资源</li>
<li>线程是处理机的独立调度单位，多个线程可以并发执行</li>
<li>线程在生命周期内会经历阻塞态、就绪态和运行态等状态变化</li>
</ul>
<h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><p><strong>用户级线程ULT：</strong>线程管理所有工作由应用程序完成</p>
<p><strong>内核级线程KLT：</strong>线程管理所有工作由内核完成</p>
<h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p><strong>多对一模型：</strong>多个用户线程映射到一个内核线程</p>
<ul>
<li>线程管理在用户空间完成，用户线程对操作系统不可见</li>
<li><strong>优点：</strong>线程管理是在用户空间进行的，效率较高<br><strong>缺点：</strong><ul>
<li>线程在使用内核时被阻塞，整个进程都会被阻塞</li>
<li>多个线程不能并行运行在多处理机上</li>
</ul>
</li>
</ul>
<p><strong>一对一模型：</strong>每个用户线程映射到内核线程</p>
<ul>
<li><strong>优点：</strong>并发能力较强<sub>当一个线程被阻塞后，允许另一个线程继续执行</sub></li>
<li><strong>缺点：</strong>:每个用户级线程都对应一个内核级线程，创建线程开销较大，影响到应用程序的性能。</li>
</ul>
<p><strong>多对多模型：</strong>$n$个用户线程映射到$m$个内核线程</p>
<ul>
<li><strong>特点：</strong>集两者所长</li>
</ul>
<h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><h3 id="为什么要处理机调度"><a href="#为什么要处理机调度" class="headerlink" title="为什么要处理机调度"></a>为什么要处理机调度</h3><p>进程时常等待I/O输入<br>若总是处理机等待外部设备，则处理机资源极大浪费<br>处理机调度可在等待外部设备时，将处理机调度其他资源<br>提高处理机利用效率</p>
<h3 id="调度层次"><a href="#调度层次" class="headerlink" title="调度层次"></a>调度层次</h3><p><strong>作业调度</strong>(高级调度)：外存后备作业分配资源，进入就绪队列</p>
<p><strong>中级调度</strong>(高级调度)：挂起队列调入内存，进入就绪队列<sub>暂时不用的挂起</sub></p>
<p><strong>进程调度</strong>(低级调度)：就绪队列分配给处理机，进入运行态</p>
<p><img src="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/7BBF531D0FF0499F86A89A0B88A510FA/70056"></p>
<h2 id="调度时机-amp-切换-amp-过程"><a href="#调度时机-amp-切换-amp-过程" class="headerlink" title="调度时机 &amp; 切换 &amp; 过程"></a>调度时机 &amp; 切换 &amp; 过程</h2><h3 id="调度顺序"><a href="#调度顺序" class="headerlink" title="调度顺序"></a>调度顺序</h3><ol>
<li>请求调度</li>
<li>运行调度程序</li>
<li>进程切换</li>
</ol>
<h3 id="不能进行调度切换情况"><a href="#不能进行调度切换情况" class="headerlink" title="不能进行调度切换情况"></a>不能进行调度切换情况</h3><ul>
<li><strong>处理中断过程中</strong>：中断过程是系统工作，不属于进程</li>
<li><strong>进程在内核程序临界区</strong>：临界区独占资源</li>
<li><strong>原子操作</strong>：加锁、解锁、中断现场保护、恢复等</li>
</ul>
<h3 id="应该调度切换"><a href="#应该调度切换" class="headerlink" title="应该调度切换"></a>应该调度切换</h3><ul>
<li>引起调度条件且当前进程无法继续运行（非剥夺调度）</li>
<li>中断或自陷处理结束后，若置上请求调度标志，即可立即进行调度切换</li>
</ul>
<h2 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h2><p><strong>非剥夺调度方式</strong></p>
<ul>
<li><p>当一个进程执行时，即使更重要进程进入就绪队列，仍然让进程继续执行直到完成或进入阻塞态，才分配处理机给就绪进程</p>
</li>
<li><p> CPU分配给进程，该进程即保持CPU直到终止或等待态。</p>
</li>
<li><p><strong>优点</strong>：实现简单、系统开销小，适用于大多数批处理系统</p>
</li>
<li><p><strong>缺点</strong>：不能用于分时系统和大多数的实时系统</p>
</li>
</ul>
<p><strong>剥夺调度方式</strong></p>
<ul>
<li>当一个进程执行时，若更重要的进程需要处理机，则立即暂停正执行进程，分配处理机给这个更为重要或紧迫的进程</li>
<li><strong>优点</strong>：提高系统吞吐率和响应效率</li>
</ul>
<h2 id="调度基本准则"><a href="#调度基本准则" class="headerlink" title="调度基本准则"></a>调度基本准则</h2><p><strong>CPU利用率：</strong>尽可能使CPU利用率最高</p>
<p><strong>系统吞吐量：</strong>单位时间CPU完成作业数量</p>
<p><strong>周转时间：</strong>作业提交到作业完成总时间<br>$$<br>周转时间=作业完成时间-作业提交时间<br>$$</p>
<p>$$<br>带权周转时间=\dfrac{作业周转时间}{作业运行时间}<br>$$</p>
<p><strong>等待时间：</strong>进程处于等待状态总和<sub>不影响执行或I/O时间</sub></p>
<p><strong>响应时间：</strong>用户提交请求到首次响应时间</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="先来先服务调度算法FCFS"><a href="#先来先服务调度算法FCFS" class="headerlink" title="先来先服务调度算法FCFS"></a>先来先服务调度算法FCFS</h3><p>选择最先进入该队列进程</p>
<ul>
<li>不可剥夺算法</li>
<li><strong>优点：</strong>算法简单，对长作业有利，有利于CPU繁忙型作业</li>
<li><strong>缺点：</strong>效率低下，对短作业不利，不利于I/O繁忙型作业</li>
</ul>
<h3 id="短作业优先调度算法SJF"><a href="#短作业优先调度算法SJF" class="headerlink" title="短作业优先调度算法SJF"></a>短作业优先调度算法SJF</h3><p>选择运行时间最短的作业</p>
<ul>
<li><strong>优点：</strong>平均等待时间最少，平均周转时间最少</li>
<li><strong>缺点</strong><ul>
<li>对长作业不利，导致长作业长期不被调度<sub>饥饿</sub></li>
<li>未考虑紧迫程度</li>
<li>只是根据估计执行时间确定</li>
</ul>
</li>
</ul>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>选择优先级最高的作业</p>
<p><strong>参考原则：</strong></p>
<ul>
<li>系统进程$&gt;$用户进程</li>
<li>交互进程$&gt;$非交互进程</li>
<li>I/O进程$&gt;$计算进程</li>
</ul>
<h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p>$$<br>响应比R_P=\dfrac{等待时间+要求服务时间}{要求服务时间}<br>$$</p>
<ul>
<li>平衡FCFS和SJF</li>
<li>属于先来先服务</li>
<li>对于等待时间足够长，响应比可升高，克服饥饿状态</li>
</ul>
<h3 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h3><p>以先来先服务原则，但仅运行一个时间片</p>
<p>时间片确定因素：系统响应时间、就绪队列进程、系统处理能力</p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>结合时间片轮转调度和优先级调度</p>
<p><img src="https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/2048548B0AD345519DEA55DA6B6803AC/70058"></p>
<ol>
<li>设置多个就绪队列，并赋予不同优先级</li>
<li>优先级越高的队列，时间片越小</li>
<li>进程进入内存后，先置于第1级队列末尾，按FCFS原则调度</li>
<li>若一个时间片无法完成，则转入之后队列</li>
<li>第$n$级队列使用时间片轮转</li>
<li>当$1\sim i-1$级队列均为空时，才调度$i$级队列运行</li>
<li>若$i$级进程运行中，又有较高优先级进程进入$1\sim i-1$队列，抢占处理机</li>
</ol>
<p><strong>优点：</strong></p>
<ul>
<li>终端型作业用户：短作业优先</li>
<li>短批处理作业用户：周期时间较短</li>
<li>长批处理作业用户：前几个队列得到部分执行，不会长期得不到处理</li>
</ul>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><p>协调进程之间制约关系</p>
<h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>一次仅允许一个进程使用的资源，访问必须互斥进行</p>
<p><strong>访问过程</strong></p>
<ul>
<li><strong>进入去：</strong>检查是否可进临界区</li>
<li><strong>临界区：</strong>访问临界资源代码</li>
<li><strong>退出区：</strong>清除临界区访问标志</li>
<li><strong>剩余区：</strong>其余代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    entry section;     <span class="comment">// 进入区</span></span><br><span class="line">    critical section;  <span class="comment">// 临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;      <span class="comment">// 退出区</span></span><br><span class="line">    remainder section; <span class="comment">// 剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>进程为协调工作次序等待</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>一个进程使用临界资源，另一个必须等待</p>
<p><strong>遵循准则</strong></p>
<ul>
<li><strong>空闲让进：</strong>临界区空闲时，允许一个请求进入临界区</li>
<li><strong>忙则等待：</strong>有进程进入临界区时，其他试图进入临界区进程必须等待</li>
<li><strong>有限等待：</strong>请求访问的进程应保证在有限时间内进入临界区</li>
<li><strong>让权等待：</strong>进程不能访问临界区时，应立即释放处理器</li>
</ul>
<h2 id="临界区互斥实现"><a href="#临界区互斥实现" class="headerlink" title="临界区互斥实现"></a>临界区互斥实现</h2><h3 id="软件实现方法"><a href="#软件实现方法" class="headerlink" title="软件实现方法"></a>软件实现方法</h3><p><strong>单标志法</strong></p>
<p>设置公用变量<code>turn</code>，作为允许进入临界区进程编号</p>
<p>但若$P_0$离开后$P_1$没有进入打算，<code>turn=1</code>恒成立，$P_0$无法再次进入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P0进程                   //P1进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>);         <span class="keyword">while</span>(turn != <span class="number">1</span>);    <span class="comment">// 进入区</span></span><br><span class="line">critical section;         critical section;    <span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">1</span>;                 turn = <span class="number">0</span>;            <span class="comment">// 退出区</span></span><br><span class="line">remainder section;        remainder section;   <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>
<p><strong>双标志法先检查</strong></p>
<p>进程访问前先检查临界资源是否正被访问</p>
<p>设置<code>flag[i]</code>表示$P_i$进程是否进入临界区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pi进程                   //Pj进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[j]);   ①         <span class="keyword">while</span>(falg[i]);  ②   <span class="comment">// 进入区</span></span><br><span class="line">flag[i] = TRUE;   ③         flag[j] = TURE;  ④   <span class="comment">// 进入区</span></span><br><span class="line">critical section;         critical section;      <span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;          flag[j] = FALSE        <span class="comment">// 退出区</span></span><br><span class="line">remainder section;        remainder section;     <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优点：</strong>不用交替进入，可连续使用</li>
<li><strong>缺点：</strong>$P_i$和$P_j$同时进入临界区，按①②③④顺序执行，会同时进入临界区<sub>检查对方<code>flag</code>和切换自己<code>flag</code>中间间隔</sub></li>
</ul>
<p><strong>双标志法后检查</strong></p>
<p>先设置自己标志，再检测对方状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pi进程                   //Pj进程</span></span><br><span class="line">flag[i] = TRUE;           flag[j] = TURE;    <span class="comment">// 进入区</span></span><br><span class="line"><span class="keyword">while</span>(flag[j]);           <span class="keyword">while</span>(falg[i]);    <span class="comment">// 进入区</span></span><br><span class="line">critical section;         critical section;  <span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;          flag[j] = FALSE;   <span class="comment">// 退出区</span></span><br><span class="line">remainder section;        remainder section; <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>
<p>双方进入临界区时，同时发现对方也要进入，造成饥饿现象</p>
<p><strong>Peterson算法</strong></p>
<p>先设置标志，再设置turn</p>
<p>同时检测另一个进程标志和不许进入标志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pi进程                   //Pj进程</span></span><br><span class="line">flag[i] = TRUE;turn = j;  flag[j] = TURE;turn = i  <span class="comment">// 进入区</span></span><br><span class="line"><span class="keyword">while</span>(flag[j]&amp;&amp;turn==j);  <span class="keyword">while</span>(falg[i]&amp;&amp; turn==i);<span class="comment">// 进入区</span></span><br><span class="line">critical section;         critical section;  <span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;          flag[j] = FALSE;   <span class="comment">// 退出区</span></span><br><span class="line">remainder section;        remainder section; <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>
<ul>
<li>请求资源前，先举起自己的Flag</li>
<li>在资源上布置“另一个进程正在使用的标签”turn</li>
<li>若**<font color="blue">对方举旗切资源标签不是自己</font>**，等待；否则访问资源</li>
<li>访问结束，放旗</li>
</ul>
<h3 id="硬件实现方法"><a href="#硬件实现方法" class="headerlink" title="硬件实现方法"></a>硬件实现方法</h3><p><strong>中断屏蔽方法</strong></p>
<p>通过禁止一切中断阻止其他进程进入临界区访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">关中断;</span><br><span class="line">临界区;</span><br><span class="line">开中断;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<p>限制了处理机交替能力，降低执行效率</p>
<p>将关中断权限交予用户不安全</p>
<p><strong>硬件指令方法</strong></p>
<p>通过<code>TextAndSet</code>原子指令使得执行代码不得中断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TestAndSet</span><span class="params">(boolean *lock)</span></span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即临界资源设置共享变量<code>lock</code>，<code>true</code>表示被占用</p>
<p>实现互斥算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">while</span> <span class="title">TestAndSet</span><span class="params">(&amp;lock)</span></span>;</span><br><span class="line">进程临界区代码段;</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">进程其他代码;</span><br></pre></td></tr></table></figure>
<p>自旋锁：通过<code>xchg</code>交换访问共享资源</p>
<ul>
<li><p>初始状态：共享资源区<code>key=1</code></p>
</li>
<li><p>原子操作<code>xchg</code>：将进程所持<code>key</code>与共享<code>key</code>互换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *addr, <span class="keyword">int</span> newval)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock xchg %0, %1&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    : <span class="string">&quot;+m&quot;</span>(*addr), <span class="string">&quot;=a&quot;</span>(result) : <span class="string">&quot;1&quot;</span>(newval))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>出临界区后，换回所持<code>key</code></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> table = YES;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">retry:</span><br><span class="line">  <span class="keyword">int</span> got = xchg(&amp;table, NOPE);</span><br><span class="line">  <span class="keyword">if</span> (got == NOPE)</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">  assert(got == YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  xchg(&amp;table, YES)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><strong>$P$操作</strong><code>wait(S)</code>：请求资源</p>
<p><strong>$V$操作</strong><code>signal(S)</code>：释放资源</p>
<h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p><code>S</code>表示资源数目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait(S)&#123;  <span class="comment">// 请求资源</span></span><br><span class="line">    <span class="keyword">while</span>(s &lt;= <span class="number">0</span>);  <span class="comment">// 资源耗尽</span></span><br><span class="line">    S = S - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(S)&#123;  <span class="comment">// 释放资源</span></span><br><span class="line">    S = S + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;  <span class="comment">// 整型资源数目</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span>  <span class="comment">// 等待该资源进程链表</span></span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;  <span class="comment">// 申请资源</span></span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;  <span class="comment">// 资源耗尽</span></span><br><span class="line">        add <span class="keyword">this</span> process to S.L;</span><br><span class="line">    &#125;</span><br><span class="line">    block(S.L);  <span class="comment">// 自我阻塞，放弃处理机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore)</span></span>&#123;  <span class="comment">// 释放资源</span></span><br><span class="line">    S.value++;  <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;  <span class="comment">// 仍有进程被阻塞</span></span><br><span class="line">        remove a process P from S.L;</span><br><span class="line">        wakeup(P);  <span class="comment">// 唤醒进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号量实现同步"><a href="#信号量实现同步" class="headerlink" title="信号量实现同步"></a>信号量实现同步</h3><p><code>S</code>为$P_1、P_2$公共信号量，$P_2$要用$P_1$语句$x$的结果</p>
<p>该方法亦可实现前驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;  <span class="comment">// 初始化信号量</span></span><br><span class="line">P1()&#123;</span><br><span class="line">    x;</span><br><span class="line">    V(S);  <span class="comment">// 告知x已完成</span></span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">    P(S);  <span class="comment">// 阻塞，检查x是否完成</span></span><br><span class="line">    y;  <span class="comment">//执行y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号量实现互斥"><a href="#信号量实现互斥" class="headerlink" title="信号量实现互斥"></a>信号量实现互斥</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">1</span>;  <span class="comment">// 资源为1</span></span><br><span class="line">P1()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);  <span class="comment">// 准备访问，加锁</span></span><br><span class="line">    进程P1临界区;</span><br><span class="line">    V(S);  <span class="comment">// 访问结束，解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    ...</span><br><span class="line">    P(S);  <span class="comment">// 准备访问，加锁</span></span><br><span class="line">    进程P2临界区;</span><br><span class="line">    V(S);  <span class="comment">// 访问结束，解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>共享数据结构实施操作的一组过程</p>
<h3 id="管程组成"><a href="#管程组成" class="headerlink" title="管程组成"></a>管程组成</h3><ul>
<li>管程名称</li>
<li>内部共享结构数据说明</li>
<li>数据结构操作过程</li>
<li>共享数据初始值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo&#123;  <span class="comment">// 定义名称</span></span><br><span class="line">    <span class="comment">// 定义数据结构</span></span><br><span class="line">    init_code()&#123;  <span class="comment">// 数据初始值</span></span><br><span class="line">        S = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    take_away()&#123;  <span class="comment">// 申请资源</span></span><br><span class="line">        对共享数据结构x一系列处理;</span><br><span class="line">        S--;</span><br><span class="line">    &#125;</span><br><span class="line">    give_back()&#123;  <span class="comment">// 归还资源</span></span><br><span class="line">    	对共享数据结构x一系列处理;</span><br><span class="line">        S++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>管程把共享资源操作封装</li>
<li>每次仅允许一个进程进入管程，实现进程互斥</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>阻塞原因定义<code>condition</code></p>
<p>每个条件变量保存一个等待队列，记录应该条件变量阻塞进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo&#123;</span><br><span class="line">    共享数据结构 S;</span><br><span class="line">    condition x;  <span class="comment">// 条件变量x</span></span><br><span class="line">    init_code()&#123;...&#125;</span><br><span class="line">    take_away()&#123;</span><br><span class="line">        <span class="keyword">if</span>(S &lt;= <span class="number">0</span>) x.wait();  <span class="comment">// 资源不够，在x上阻塞等待</span></span><br><span class="line">        资源足够，分配资源，做一系列处理</span><br><span class="line">    &#125;</span><br><span class="line">    give_back()&#123;</span><br><span class="line">        归还资源，做一系列处理;</span><br><span class="line">        <span class="keyword">if</span>(有进程等待) x.signal;  <span class="comment">// 唤醒阻塞进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>条件变量 &amp; 信号量</strong></p>
<ul>
<li>相似点：<code>wait/signal</code>类似于<code>P/V</code></li>
<li>不同点：条件变量没有值，仅实现排队等待功能；信号量有值，反映剩余资源数</li>
</ul>
<p>需要等待条件满足时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (!cond) &#123;</span><br><span class="line">  wait(&amp;cv, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">assert(cond);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 互斥锁保证了在此期间条件 cond 总是成立</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>其他线程条件可能被满足时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broadcast(&amp;cv);</span><br></pre></td></tr></table></figure>


<h2 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><p>同步互斥问题</p>
<p><strong>问题描述</strong></p>
<p>一组生产者和一组消费者共享一个初始为空、大小为$n$的缓冲区，<br>只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待<br>只有缓冲区不空时，消费者才能从中取出消息，否则必须等待<br>缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 临界区互斥信号量</span></span><br><span class="line">semaphore empty = n;  <span class="comment">// 空闲缓冲区</span></span><br><span class="line">semaphore full = <span class="number">0</span>;  <span class="comment">// 缓冲区初始化为空</span></span><br><span class="line">producer()&#123;  <span class="comment">// 生产者进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        produce a item in nextp;  <span class="comment">// 生产数据</span></span><br><span class="line">        P(empty);  <span class="comment">// 获取缓冲区单元</span></span><br><span class="line">        P(mutex);  <span class="comment">// 互斥，进入临界区</span></span><br><span class="line">        add nextp to buffer;  <span class="comment">// 数据放入缓冲区</span></span><br><span class="line">        V(mutex);  <span class="comment">// 离开临界区，释放互斥</span></span><br><span class="line">        V(full);  <span class="comment">// 释放缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">consumer()&#123;  <span class="comment">// 消费者进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(full);  <span class="comment">// 获取缓冲区单元</span></span><br><span class="line">        P(mutex);  <span class="comment">// 互斥，进入临界区</span></span><br><span class="line">        remove an item from buffer;  <span class="comment">// 缓冲区取出数据</span></span><br><span class="line">        V(mutex);  <span class="comment">// 离开临界区，释放互斥</span></span><br><span class="line">        V(empty);  <span class="comment">// 空缓冲区++</span></span><br><span class="line">        consume the item;  <span class="comment">// 消费数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p><strong>问题描述：</strong><br>读者和写者两组并发共享一个文件<br>允许多个读者可以同时对文件执行读操作<br>只允许一个写者往文件中写信息<br>任一写者在完成写操作之前不允许其他读者或写着工作<br>写者执行写操作前，应让已有的读者和写者全部退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 当前读者数量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 更新count互斥</span></span><br><span class="line">semaphore rw = <span class="number">1</span>;  <span class="comment">// 保证读者写者互斥访问</span></span><br><span class="line"></span><br><span class="line">write()&#123;  <span class="comment">// 写者进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(rw);  <span class="comment">// 互斥访问共享文件</span></span><br><span class="line">		writing;  <span class="comment">// 写入</span></span><br><span class="line">		V(rw);  <span class="comment">// 释放共享文件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;  <span class="comment">// 读者进程</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		P(mutex);  <span class="comment">// 互斥访问count变量</span></span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>)  <span class="comment">// 第一个读进程读共享文件</span></span><br><span class="line">			P(rw);  <span class="comment">// 阻止写进程写</span></span><br><span class="line">		count++;  <span class="comment">// 读者计数器++</span></span><br><span class="line">		V(mutex);  <span class="comment">// 释放互斥变量</span></span><br><span class="line">		reading; <span class="comment">// 读取</span></span><br><span class="line">		P(mutex);  <span class="comment">// 互斥访问count变量</span></span><br><span class="line">		count--;</span><br><span class="line">		<span class="keyword">if</span>(count == <span class="number">0</span>)  <span class="comment">// 当最后一个读进程读完共享文件</span></span><br><span class="line">			V(rw);  <span class="comment">// 允许写进程</span></span><br><span class="line">		V(mutex);  <span class="comment">// 释放互斥变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p><strong>问题描述：</strong></p>
<p>一张桌坐着5名哲学家<br>每两名哲学家之间桌上摆一根筷子<br>当哲学家饥饿时，才试图拿起左、右两根筷子<br>若筷子已在他人手上，则需等待<br>只有当哲学家同时拿起两根筷子才可进餐</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopsticks[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;  <span class="comment">// 初始化信号量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 设置取筷子信号量</span></span><br><span class="line">Pi()&#123;  <span class="comment">// i号哲学家进程</span></span><br><span class="line">    P(mutex);  <span class="comment">// 取筷子前获得互斥</span></span><br><span class="line">    P(chopsticks[i]);  <span class="comment">// 取左筷子</span></span><br><span class="line">    P(chopsticks[(i + <span class="number">1</span>) &amp; <span class="number">5</span>]);  <span class="comment">// 取右边筷子</span></span><br><span class="line">    V(mutex);  <span class="comment">// 释放取筷子信号量</span></span><br><span class="line">    eat;  <span class="comment">// 进餐</span></span><br><span class="line">    V(chopsticks[i]);  <span class="comment">// 放回左边筷子</span></span><br><span class="line">    V(chopsticks[(i + <span class="number">1</span>) &amp; <span class="number">5</span>]);  <span class="comment">// 放回右边筷子</span></span><br><span class="line">    think;  <span class="comment">// 继续思考</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>当一名哲学家左右筷子均可用，才允许抓起筷子</p>
<ul>
<li>避免贪心，多考虑一步</li>
</ul>
<p>万能方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (!(avail[lhs] &amp;&amp; avail[rhs])) &#123;</span><br><span class="line">  wait(&amp;cv, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">avail[lhs] = avail[rhs] = <span class="literal">false</span>;</span><br><span class="line">mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line">avail[lhs] = avail[rhs] = <span class="literal">true</span>;</span><br><span class="line">broadcast(&amp;cv);</span><br><span class="line">mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>管理者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tphilosopher</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  send_request(id, EAT);</span><br><span class="line">  P(allowed[id]); <span class="comment">// waiter 会把叉子递给哲学家</span></span><br><span class="line">  philosopher_eat();</span><br><span class="line">  send_request(id, DONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    (id, status) = receive_request();</span><br><span class="line">    <span class="keyword">if</span> (status == EAT) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == DONE) &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p><strong>问题描述</strong></p>
<p>有三个抽烟者和一个供应者进程<br>每个抽烟者不停卷烟并抽掉<br>但要卷起并抽掉一支烟，抽烟者需要有烟草、纸、胶水<br>三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水<br>供应者进程无限地提供三种材料<br>供应者每次将两种材料放到桌子上<br>拥有剩下那种材料的抽烟者卷一根烟并抽掉它<br>并给供应者一个信号告诉已完成<br>此时供应者就会将另外两种材料放到桌上<br>如此重复（让三个抽烟者轮流地抽烟)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;  <span class="comment">// 存储随机数</span></span><br><span class="line">semaphore offer1 = <span class="number">0</span>;  <span class="comment">// 定义烟草和纸组合</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;  <span class="comment">// 定义烟草和胶水组合</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;  <span class="comment">// 定义纸和胶水组合</span></span><br><span class="line">process finish = <span class="number">0</span>;  <span class="comment">// 表示抽烟是否完成</span></span><br><span class="line"><span class="function">process <span class="title">P1</span><span class="params">()</span></span>&#123;  <span class="comment">// 供应者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        num = num % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            V(offer1);  <span class="comment">// 提供烟草和纸</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line">            V(offer2);  <span class="comment">// 提供烟草和胶水</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            V(offer3);  <span class="comment">// 提供纸和胶水</span></span><br><span class="line">        任意两种材料放在桌上;</span><br><span class="line">        P(finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">process <span class="title">P2</span><span class="params">()</span></span>&#123;  <span class="comment">// 拥有烟草者</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            P(offer3);  </span><br><span class="line">            取走纸和胶水，卷烟;</span><br><span class="line">            V(finish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">process <span class="title">P3</span><span class="params">()</span></span>&#123;  <span class="comment">// 拥有纸者</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            P(offer2);</span><br><span class="line">            取走烟草和胶水，卷烟;</span><br><span class="line">            V(finish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">process <span class="title">P4</span><span class="params">()</span></span>&#123;  <span class="comment">// 拥有胶水者</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            P(offer1);</span><br><span class="line">            取走烟草和纸，卷烟;</span><br><span class="line">            V(finish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>多个进程竞争资源造成互相等待</p>
<h3 id="死锁原因"><a href="#死锁原因" class="headerlink" title="死锁原因"></a>死锁原因</h3><ul>
<li>系统资源竞争</li>
<li>进程推进顺序非法</li>
<li>必要条件：互斥、不剥夺、请求并保持、循环等待</li>
</ul>
<h2 id="死锁处理策略"><a href="#死锁处理策略" class="headerlink" title="死锁处理策略"></a>死锁处理策略</h2><p><strong>死锁预防：</strong>设置限制条件，破坏必要条件</p>
<p><strong>避免死锁：</strong>动态分配时，防止系统进入不安全状态</p>
<p><strong>死锁检测及解除：</strong>通过系统检测及时检测，采取某种措施</p>
<table>
<thead>
<tr>
<th></th>
<th>资源分配策略</th>
<th>各种可能模式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>死锁预防</strong></td>
<td>保守，宁可资源闲置</td>
<td>一次请求所有资源，资源剥夺，资源按序分配</td>
<td>适用突发处理的进程，不必进行剥夺</td>
<td>效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源</td>
</tr>
<tr>
<td><strong>死锁避免</strong></td>
<td>是“预防”和“检测”的折中</td>
<td>寻求可能的安全允许顺序</td>
<td>不必进行剥夺</td>
<td>必须知道奖来资源需求；进程不能被长时间阻塞</td>
</tr>
<tr>
<td><strong>死锁检测</strong></td>
<td>宽松，只要允许就分配资源</td>
<td>定期检查死锁是否已经发生</td>
<td>不延长进程初始化时间，允许对死锁现场处理</td>
<td>通过剥夺解除死锁，造成损失</td>
</tr>
</tbody></table>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p><strong>破坏互斥条件：</strong>不可行</p>
<p><strong>破坏不剥夺条件：</strong></p>
<p>释放已保持的所有资源</p>
<p>常用于状态易于保存和恢复的资源</p>
<p><strong>破坏请求并保持条件：</strong></p>
<p>运行前一次申请完全部资源</p>
<p>实现简单，但资源严重浪费</p>
<p>易导致饥饿现象</p>
<p><strong>破坏循环等待条件：</strong></p>
<p>采用顺序资源分配法</p>
<p><strong><font color="red">给系统中资源编号，规定每个进程必须按编号递增顺序请求资源</font></strong></p>
<p>优点：编号必须相对稳定</p>
<p>缺点：造成资源的浪费</p>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><h3 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h3><p>系统按照某种进程推进顺序为每个进程$P_i$分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成</p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><strong>数据结构描述</strong></p>
<p>可利用资源向量<code>Available</code>：含$m$个元素的数组，其中每个元素代表一类可用的资源数目(<code>Available[j]=K</code>表示系统现有$R_j$类资源$K$个)</p>
<p>最大需求矩阵$Max_{n\times m}$：行代表进程；列代表某类资源</p>
<p>分配矩阵$Allocation_{m\times n}$：每类资源当前分配给每个进程的资源数</p>
<p>需求举证$Need_{m\times n}$：每个进程接下来最多还需要多少资源</p>
<p><strong>算法描述</strong></p>
<p>设$Request_i[j]=K$即进程$P_i$需要$j$类资源$K$个</p>
<p>当$P_i$发出资源请求后，按下述步骤检查</p>
<ol>
<li><p>$Request_i[j]\le Need[i,j]$，转向②；否则认为出错<sub>所需资源超过最大值</sub></p>
</li>
<li><p>$Request_i[j]\le Available[j]$，转向步骤③；$P_i$须等待<sub>尚无足够资源</sub></p>
</li>
<li><p>系统试探将资源分配给进程$P_i$，并修改数据结构数值</p>
<p>$Available=Available-Request_i;\Allocation[i,j]=Allocation[i,j]+Request_i[j];\Need[i,j]=Need[i,j]-Request_i[j]$</p>
</li>
<li><p>系统执行安全性算法，判断是否安全<br>安全则正式分配资源给进程$P_i$<br>否则将本次试探作废</p>
</li>
</ol>
<p><strong>安全性算法</strong></p>
<p>工作向量$Work$：系统中剩余可用资源数，初始$Work=Available$</p>
<ol>
<li><p>初始时安全序列为空</p>
</li>
<li><p>从$Need$找到符合条件的行：</p>
<p>该行对应进程不在安全序列中，且该行小于等于$Work$向量</p>
<p>找到把对应进程加入安全序列</p>
<p>找不到执行步骤④</p>
</li>
<li><p>进程$P_i$进入安全序列后可顺利执行，直到完成，并释放资源</p>
<p>$Work=Work+Allocation[i]$</p>
</li>
<li><p>若此时安全序列中已有所有进程，则系统处于安全状态</p>
</li>
</ol>
<h2 id="死锁检测-amp-解除"><a href="#死锁检测-amp-解除" class="headerlink" title="死锁检测 &amp; 解除"></a>死锁检测 &amp; 解除</h2><h3 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h3><p>$S$死锁$\Leftrightarrow$$S$资源分配图不可完全简化</p>
<h3 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h3><ul>
<li><strong>资源剥夺法：</strong>挂起某些死锁进程，并抢占其资源</li>
<li><strong>撤销进程法：</strong>强制撤销部分死锁进程并剥夺资源</li>
<li><strong>进程回退法：</strong>让进程回退到足以回避死锁地步</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="prev" title="操作系统概述">
      <i class="fa fa-chevron-left"></i> 操作系统概述
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="next" title="内存管理">
      内存管理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-amp-%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">进程 &amp; 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81-amp-%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.1.</span> <span class="nav-text">进程状态 &amp; 转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.1.2.</span> <span class="nav-text">进程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%BB%87"><span class="nav-number">1.1.3.</span> <span class="nav-text">进程组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">1.1.4.</span> <span class="nav-text">进程通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B-amp-%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">线程 &amp; 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">1.2.2.</span> <span class="nav-text">线程属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.3.</span> <span class="nav-text">线程实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.4.</span> <span class="nav-text">多线程模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-number">2.</span> <span class="nav-text">处理机调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-number">2.0.1.</span> <span class="nav-text">为什么要处理机调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%B1%82%E6%AC%A1"><span class="nav-number">2.0.2.</span> <span class="nav-text">调度层次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA-amp-%E5%88%87%E6%8D%A2-amp-%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">调度时机 &amp; 切换 &amp; 过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.1.1.</span> <span class="nav-text">调度顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E8%B0%83%E5%BA%A6%E5%88%87%E6%8D%A2%E6%83%85%E5%86%B5"><span class="nav-number">2.1.2.</span> <span class="nav-text">不能进行调度切换情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E8%AF%A5%E8%B0%83%E5%BA%A6%E5%88%87%E6%8D%A2"><span class="nav-number">2.1.3.</span> <span class="nav-text">应该调度切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">进程调度方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%9F%BA%E6%9C%AC%E5%87%86%E5%88%99"><span class="nav-number">2.3.</span> <span class="nav-text">调度基本准则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95FCFS"><span class="nav-number">2.4.1.</span> <span class="nav-text">先来先服务调度算法FCFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95SJF"><span class="nav-number">2.4.2.</span> <span class="nav-text">短作业优先调度算法SJF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.3.</span> <span class="nav-text">优先级调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.4.</span> <span class="nav-text">高响应比优先调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.5.</span> <span class="nav-text">时间片轮转调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.6.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="nav-number">3.0.1.</span> <span class="nav-text">临界资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">3.0.2.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5"><span class="nav-number">3.0.3.</span> <span class="nav-text">互斥</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.</span> <span class="nav-text">临界区互斥实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">软件实现方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">硬件实现方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.2.1.</span> <span class="nav-text">整型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.2.2.</span> <span class="nav-text">记录型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5"><span class="nav-number">3.2.3.</span> <span class="nav-text">信号量实现同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="nav-number">3.2.4.</span> <span class="nav-text">信号量实现互斥</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">管程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E7%BB%84%E6%88%90"><span class="nav-number">3.3.1.</span> <span class="nav-text">管程组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.2.</span> <span class="nav-text">条件变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.</span> <span class="nav-text">同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.1.</span> <span class="nav-text">生产者-消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.2.</span> <span class="nav-text">读者-写者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.3.</span> <span class="nav-text">哲学家进餐问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.4.</span> <span class="nav-text">吸烟者问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%8E%9F%E5%9B%A0"><span class="nav-number">4.0.1.</span> <span class="nav-text">死锁原因</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">4.1.</span> <span class="nav-text">死锁处理策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="nav-number">4.2.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="nav-number">4.3.</span> <span class="nav-text">死锁避免</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="nav-number">4.3.1.</span> <span class="nav-text">系统安全状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.2.</span> <span class="nav-text">银行家算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B-amp-%E8%A7%A3%E9%99%A4"><span class="nav-number">4.4.</span> <span class="nav-text">死锁检测 &amp; 解除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86"><span class="nav-number">4.4.1.</span> <span class="nav-text">死锁定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4"><span class="nav-number">4.4.2.</span> <span class="nav-text">死锁解除</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jarrycow"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jarrycow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jarrycow</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
