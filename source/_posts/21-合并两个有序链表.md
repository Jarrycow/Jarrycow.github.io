---
title: 21. 合并两个有序链表
date: 2022-07-26 15:12:34
tags: 
  - 算法
  - 力扣
categories:
  - 力扣
abbrlink: leetcode21
---

# 题目描述

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

> 输入：l1 = [1,2,4], l2 = [1,3,4]
> 输出：[1,1,2,3,4,4]

**示例 2：**

> 输入：l1 = [], l2 = []
> 输出：[]

**示例 3：**

> 输入：l1 = [], l2 = [0]
> 输出：[0]

**提示：**

- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

# 题解

## 自己

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null)    return list2;
        if(list2 == null)    return list1;
        ListNode head = new ListNode();  // 生成的结果
        ListNode p = list1, q = list2, node = head;  // 指向l1，l2的指针
        while(p != null  &&  q != null){
            node.next = new ListNode();
            node = node.next;
            if(p.val < q.val){
                node.val = p.val;
                p = p.next;
            }else{
                node.val = q.val;
                q = q.next;
            }
        }
        if(p != null){
            node.next = p;
        }
        if(q != null){
            node.next = q;
        }
        return head.next;
    }
}
```

## 官方

### 递归

- 终止条件：当两个链表都为空时，表示我们对链表已合并完成。
- 如何递归：我们判断 `l1` 和 `l2` 头结点哪个更小，然后较小结点的 `next` 指针指向**其余结点的合并结果。（调用递归）**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        else if (l2 == null) {
            return l1;
        }
        else if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        }
        else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }

    }
}
```

时间复杂度：$O(m+n)$

空间复杂度：$O(m+n)$