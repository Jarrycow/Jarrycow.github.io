---
title: 14. 最长公共前缀
date: 2022-07-26 12:40:02
tags: 
  - 算法
  - 力扣
categories:
  - 力扣
abbrlink: leetcode14
---

# 题目描述

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1：**

> 输入：strs = ["flower","flow","flight"]
> 输出："fl"

**示例 2：**

> 输入：strs = ["dog","racecar","car"]
> 输出：""
> 解释：输入不存在公共前缀。


**提示：**

- `1 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]` 仅由小写英文字母组成

# 题解

## 自己

先求出最短的字符串，然后以最短的字符串开始横向扫描

（所以为啥要求最短的字符串？）

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        String result = "";
        int i_min = 0, min = strs[0].length();
        for(int i = 0 ; i < strs.length ; ++i){
            if(strs[i].length() < min){
                min = strs[i].length();
                i_min = i;
            }
        }
        char[] chs = strs[i_min].toCharArray();
        for(int i = 0 ; i < chs.length ; ++i){
            result += chs[i];
            for(String str : strs){
                if(str.charAt(i) != chs[i]){
                    result = result.substring(0, result.length() - 1);
                    return result;
                }
            }
        }
        return result;
    }
}
```

## 官方

以$LCP(S_1\cdots S_n)$表示字符串$S_1\cdots S_n$最长公共前缀

### 横向扫描

$LCP(S_1\cdots S_n)=LCP(LCP(LCP(S_1, S_2), S_3), S_4)$

依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀

如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {  // 空串 
            return "";
        }
        String prefix = strs[0];  // 以首个字符串为LCP
        int count = strs.length;  // LCP长度
        for (int i = 1; i < count; i++) {
            prefix = longestCommonPrefix(prefix, strs[i]);  // 求当前LCP和str的LCP
            if (prefix.length() == 0) {  // LCP已为空串直接返回
                break;
            }
        }
        return prefix;
    }

    public String longestCommonPrefix(String str1, String str2) {  // 求两个字符串最长前缀
        int length = Math.min(str1.length(), str2.length());  // 长度
        int index = 0;
        while (index < length && str1.charAt(index) == str2.charAt(index)) {
            index++;
        }
        return str1.substring(0, index);
    }
}
```

时间复杂度：$O(mn)$——$m ：$字符串的平均长度；$n：$字符串的数量

空间复杂度：$O(1)$

### 纵向扫描

![](https://assets.leetcode-cn.com/solution-static/14/14_fig2.png)

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) {
            return "";
        }
        int length = strs[0].length();
        int count = strs.length;
        for (int i = 0; i < length; i++) {
            char c = strs[0].charAt(i);
            for (int j = 1; j < count; j++) {
                if (i == strs[j].length() || strs[j].charAt(i) != c) {
                    return strs[0].substring(0, i);
                }
            }
        }
        return strs[0];
    }
}
```

时间复杂度：$O(mn)$

空间复杂度：$O(1)$

# 知识点

**字符串分割**

```java
s.substring(start, end);
```

