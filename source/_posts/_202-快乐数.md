---
title: 202.快乐数
author: Jarrycow
cover: false
top: false
mathjax: true
categories:
  - 力扣
tags:
  - 算法
keywords: 202.快乐数
abbrlink: leetcode202
date: 2022-10-26 20:17:22
---



<!--more-->

# 题目描述

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

> 输入：n = 19
> 输出：true
> 解释：
> $1^2+9^2=82$
> $6^2+8^2=100$
> $1^2+0^2+0^2=1$

**示例 2：**

> 输入：n = 2
> 输出：false

# 题解

## 自己

```java
class Solution {
    public boolean isHappy(int n) {
        if(n == 0)
            return false;
        int result = 0;
        while(result >= 10 || n != 0){
            result += (n%10) * (n%10);
            n /= 10;
            if(n == 0)
                if(result < 10)
                   break;
                n = result;
                result = 0;
        }

        return (result == 1);
    }
}
```

在比如4那里，算到最后result并不会小于10，会发生循环

```java
class Solution {
    public boolean isHappy(int n) {
        int result = 0;
        
        while(n != 0){
            int flag = 0;
            result += (n%10) * (n%10);
            n /= 10;
            if(n == 0){
                flag++;
                if(result == 1)
                   return true;
                n = result;
                result = 0;
            }
            if(flag > 10){
                // System.out.println(flag);
                return false;
            }
        }
        return (result == 1);
    }
}
```

所以就卡死多少次之后直接报错，不过还是超时

## 官方

其实就是循环检测的问题

![](https://assets.leetcode-cn.com/solution-static/202/202_fig2.png)

### 哈希表

```java
class Solution {
    private int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            totalSum += d * d;
        }
        return totalSum;
    }

    public boolean isHappy(int n) {
        Set<Integer> seen = new HashSet<>();
        while (n != 1 && !seen.contains(n)) {
            seen.add(n);
            n = getNext(n);
        }
        return n == 1;
    }
}
```

时间复杂度：$O(\log n)$

### 快慢指针

![](https://assets.leetcode-cn.com/solution-static/202/1.jpg)

慢指针走一步，快指针走两步，如果快慢相遇即为循环

```java
class Solution {
     public int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            totalSum += d * d;
        }
        return totalSum;
    }

    public boolean isHappy(int n) {
        int slowRunner = n; 
        int fastRunner = getNext(n);
        while (fastRunner != 1 && slowRunner != fastRunner) {  // 慢指针走一步，快指针走两步
            slowRunner = getNext(slowRunner);
            fastRunner = getNext(getNext(fastRunner));
        }
        return fastRunner == 1;
    }
}
```

