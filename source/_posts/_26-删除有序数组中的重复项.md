---
title: 26. 删除有序数组中的重复项
date: 2022-07-26 15:33:40
tags: 
  - 算法
  - 力扣
categories:
  - 力扣
abbrlink: leetcode26
---

# 题目描述

给你一个 **升序排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。

由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 `k` 个元素，那么 `nums` 的前 `k` 个元素应该保存最终结果。

将最终结果插入 `nums` 的前 `k` 个位置后返回 `k` 。

不要使用额外的空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

**判题标准:**

系统会用下面的代码来测试你的题解:

```java
int[] nums = [...]; // 输入数组
int[] expectedNums = [...]; // 长度正确的期望答案

int k = removeDuplicates(nums); // 调用

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有断言都通过，那么您的题解将被 **通过**。

**示例 1：**

> 输入：nums = [1,1,2]
> 输出：2, nums = [1,2,_]
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

**示例 2：**

> 输入：nums = [0,0,1,1,1,2,2,3,3,4]
> 输出：5, nums = [0,1,2,3,4]
> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。

**提示：**

- `1 <= nums.length <= 3 * 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 已按 **升序** 排列

# 题解

## 自己

### 1st

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;
        if (nums.length == 1)
            return 1;
        int start = 0, end = 0; // 重复起始、结束元素
        int count = nums.length; // 数组长度
        while (end < count) {
            while (nums[start] == nums[end] && end < count) { // 遇到重复元素，尾指针一直前移
                if (nums[end] == nums[start]){
                    ++end;
                    if(end == count)
                        // break;
                        return ++start;
                }
            }
            for (int i = 0; i + end < nums.length; ++i) {
                nums[start + i + 1] = nums[end + i];
            }
            count -= (end - start - 1);
            ++start;
        }
        return count;
    }
}
```

**错误**

输入：[-1,0,0,0,0,3,3]

输出：[-1,0,3,3]

预期结果：[-1,0,3]

```++end```时没有及时核验`end`范围，越界

### 2nd

重新考虑，只要将没有见过的元素覆盖即可

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums == null || nums.length == 0)
            return 0;
        int slow = 0, fast = 0;
        Map<Integer, Boolean> hashtable = new HashMap<Integer, Boolean>();  // 初始化字典<>
        while(slow < nums.length  &&  fast < nums.length){
            if(!(hashtable.containsKey(nums[fast]))){
                hashtable.put(nums[fast], true);
                nums[slow] = nums[fast];
                ++slow;++fast;
            }else{
                ++fast;
            }
        }
        int result = hashtable.size();
        return result;
    }
}
```

## 官方

### 双指针

定义两个指针 $\textit{fast} $和 $\textit{slow}$分别为快指针和慢指针

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        if (n == 0)    return 0;  // 空数组返回
        
        int fast = 1, slow = 1;  // 定义快慢指针
        while (fast < n) {  // 快指针小于数组长度
            if (nums[fast] != nums[fast - 1]) {  // 快指针和前一个不同
                nums[slow] = nums[fast];  // 慢指针覆盖
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
}
```

之前个人做法过于复杂了，实际不用再求长度什么的