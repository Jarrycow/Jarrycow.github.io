---
title: 3. 无重复字符的最长子串
date: 2022-07-22 17:45:25
tags: 
  - 算法
  - 力扣
categories:
  - 力扣
abbrlink: leetcode3
---

# 题目描述

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

**示例 2:**

> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

**示例 3:**

> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

**提示：**

- 0 <= `s.length `<= 5 * $10^4$
- `s` 由英文字母、数字、符号和空格组成

# 题解

## 初次提交

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int[] pre = new int[26 + 1 + 10]; // 0123456789 a-z
        int[] node = new int[26 + 1 + 10];
        int[] distance = new int[26 + 1 + 10];
        Arrays.fill(pre, -1);
        Arrays.fill(node, -1);
        Arrays.fill(distance, 0);
        /* 索引最长间隔 */
        for (int i = 0; i < s.length(); ++i) {
            int pe = (s.charAt(i) >= '0' && s.charAt(i) <= '9') ? (s.charAt(i) - 48)
                    : ((s.charAt(i) >= 'a' && s.charAt(i) <= 'z') ? (s.charAt(i) - 97 + 11) : (s.charAt(i) - 32 + 10)); // 对应填充位置
            if (pre[pe] == -1){
                pre[pe] = i;
                distance[pe] = 0;
            }
            else{
                node[pe] = i;
                distance[pe] = node[pe] - pre[pe];
                pre[pe] = i;
            }
        }
        int maxNum = Arrays.stream(distance).max().getAsInt();
        return maxNum;
    }
}
```

**思路**

做`0-9 a-z`的对应的

`pre`：指向前一个元素的指针

`node`：指向当前元素的指针

`distance`：相同元素之间的距离

**错误**

输入："aab"

输出：1

预期结果：2

**错误原因**

未考虑元素读完后的距离

## 再次提交

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int[] pre = new int[26 + 1 + 10];  // 前一个元素指针 // 0123456789 a-z
        int[] node = new int[26 + 1 + 10];  // 当前元素指针
        int[] distance = new int[26 + 1 + 10];  // 该元素前后距离
        int[] window = new int[26+1+10];  // 滑动窗口
        Arrays.fill(pre, -1);
        Arrays.fill(node, -1);
        Arrays.fill(distance, 0);
        
        /* 索引最长间隔 */
        for (int i = 0; i < s.length(); ++i) {
            int pe = (s.charAt(i) >= '0' && s.charAt(i) <= '9') ? (s.charAt(i) - 48)
                    : ((s.charAt(i) >= 'a' && s.charAt(i) <= 'z') ? (s.charAt(i) - 97 + 11) : (s.charAt(i) - 32 + 10)); // 对应填充位置
            if (pre[pe] == -1){
                pre[pe] = i;
                distance[pe] = 0;
            }
            else{
                node[pe] = i;
                distance[pe] = node[pe] - pre[pe];
                pre[pe] = i;
            }
            
        }

        int maxNum = Arrays.stream(distance).max().getAsInt();  // 得到相同元素最大距离
        
        Map<Character, Boolean> hashtable = new HashMap<Character, Boolean>();  // 字符：存在
        int i;
        for(i = 0; i < s.length(); ++i){  // 遍历之前
            if(hashtable.containsKey(s.charAt(i))){
                break;
            }else{
                hashtable.put(s.charAt(i), true);
            }
        }
        int first = i;
        hashtable.clear();
        for(i = s.length() - 1; i > 0; --i){
            if(hashtable.containsKey(s.charAt(i))){
                break;
            }else{
                hashtable.put(s.charAt(i), true);
            }
        }
        int last = s.length() - i - 1;

        maxNum = (first > last) ? 
                ((maxNum > first) ? (maxNum) : (first)) : 
                ((maxNum > last) ? (maxNum) : (last));


        return maxNum;
    }
}
```

这次考虑了读取头尾不重复分段

但似乎开始考虑的“求取中间的相同的间距”想法就不对，因为相同字符间可能夹了其他相同字符

**错误**

输入："abba"

输出：3

预期结果：2

# 也许能称得上知识点的玩意

**哈希表的清理**

```java
hashtable.clear();
```

