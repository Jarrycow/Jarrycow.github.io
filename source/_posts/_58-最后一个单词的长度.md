---
title: 58. 最后一个单词的长度
date: 2022-08-01 14:39:10
tags: 
  - 算法
  - 力扣
categories:
  - 力扣
abbrlink: leetcode58
---

# 题目描述

给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 **最后一个** 单词的长度。

**单词** 是指仅由字母组成、不包含任何空格字符的最大子字符串。

<!-- more -->

**示例 1：**

> 输入：s = "Hello World"
> 输出：5
> 解释：最后一个单词是“World”，长度为5。

**示例 2：**

> 输入：s = "   fly me   to   the moon  "
> 输出：4
> 解释：最后一个单词是“moon”，长度为4。

**示例 3：**

> 输入：s = "luffy is still joyboy"
> 输出：6
> 解释：最后一个单词是长度为6的“joyboy”。

**提示：**

- `1 <= s.length <= 10^4`

- `s` 仅有英文字母和空格 `' '` 组成
- `s` 中至少存在一个单词

# 题解

## 自己

设置标志记录“是否遇到空格”

若遇到空格之后又遇到字母，则重新计数

```java
class Solution {
    public int lengthOfLastWord(String s) {
        if(s == ""  ||  s == null)
            return 0;
        int result = 0;  // 记录单词长度
        int point = 0;  //  指向字符的指针
        boolean reset = true;  // 重置指令：当接触到空格
        while(point < s.length()){
            if(s.charAt(point) == ' '){  // 指到空格，标志重置
                reset = true;
            }
            else if(reset){  // 指到了字母，且标志重置
                reset = false;  // 标志转换
                result = 1;  // 指向第一个
            }  // 即单词第一个
            else if(!reset){  // 指向不是第一个字母
                ++result;
            }
            ++point;
        }
        return result;
    }
}
```

时间复杂度：$O(n)$——遍历

空间复杂度：$O(1)$

## 改进

倒序遍历

先跳过空格

到下一次遇到空格停止

```java
class Solution {
    public int lengthOfLastWord(String s) {
        int result = 0; // 记录单词长度
        int point = s.length() - 1; // 指向字符的指针

        while (point >= 0 && s.charAt(point) == ' ') // 从最后开始计数，跳过所有空格
            --point;
        do {
            ++result;
            --point;
        } while (point >= 0 && s.charAt(point) != ' ');

        return result;
    }
}
```

