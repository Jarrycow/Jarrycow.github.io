---
title: 进程管理
date: 2022-07-13 16:44:14
tags:
  - 操作系统
  - 计算机基础
categories:
  - 计算机基础
abbrlink: Process_Management
---

# 进程 & 线程

## 进程

**进程控制块：**（PCB）描述进程基本情况和运行状态<sub>进程存在唯一标志</sub>

**进程映像(进程实体)：**程序段、相关数据段、PCB

**进程：**进程实体的运行过程，系统进行资源分配和调度的一个独立单位

**进程特征：**

- 动态性(最重要特点)
- 并发性
- 独立性
- 异步性
- 结构性

### 进程状态 & 转换

**基本状态：**运行态、就绪态、阻塞态

- **运行态：**进程在处理机上运行
- **就绪态：**进程获得了除处理机外所有资源，得到处理机立即运行<sub>排成队列</sub>
- **阻塞态：**等待某事件暂停运行<sub>资源、I/O</sub>
- **创建态：**进程正在被创建
- **结束态：**进程从系统消失

![](https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/E296C0365BA348F6B7B0D610D5BC6AD2/69245)

- **就绪态$\rightarrow$运行态：**获得处理机资源<sub>分派处理机时间片</sub>
- **运行态$\rightarrow$就绪态：**时间片用完/更高优先级进程就绪
- **运行态$\rightarrow$阻塞态：**进程请求资源或等待某一事件
- **阻塞态$\rightarrow$就绪态：**进程等待事件到来

### 进程控制

1. **进程创建**

   1. 为新进程分配一个唯一**进程标识号**，申请一个**空白PCB**

   2. 为进程**分配资源**，为新进程的程序和数据及用户栈分配必要的**内存空间**<sub>PCB中体现</sub>

      若资源不足，则处于阻塞态，等待内存资源

   3. **初始化 PCB**<sub>标志信息、处理机状态信息、处理机控制信息、进程优先级</sub>

   4. 若进程就绪队列能够接纳新进程，则**插入就绪队列**，等待被调度运行

2. **进程终止**

   - **引起**
     - 正常结束
     - 异常结束
     - 外界干预
   - **撤销原语过程**
     1. 根据被终止进程的标识符，**检索PCB**，读取进程状态
     2. 若处于运行态，**立即终止该进程**
     3. 若该进程还有子孙进程，终止所有子孙进程
     4. **将该进程所有资源归还**父进程或操作系统
     5. 将该**PCB从所在队列删除**

3. **进程阻塞 & 唤醒**

   **阻塞原语过程：**

   1. 根据被阻塞进程的标识符，**检索PCB**，读取进程状态
   2. 若处于运行态，保护现场，**转为阻塞态**，停止运行
   3. 把该**PCB插入相应事件等待队列**

   **唤醒原语过程：**

   1. 根据被阻塞进程的标识符，**检索PCB**
   2. 将其从等待队列中移出，**转为就绪态**
   3. 把该**PCB插入就绪队列**，等待调度程序调度

4. **进程切换**

   1. **保存**处理机上下文<sub>程序计数器、其他寄存器</sub>
   2. **更新PCB**信息
   3. 进程**PCB移入相应的队列**
   4. 选择另一个**进程执行**，更新其PCB
   5. **更新内存**管理的数据结构
   6. **恢复**处理机上下文

### 进程组织

**进程控制块PCB**（核心）

| 进程描述信息  | 进程控制和管理信息 | 资源分配清单 | 处理机相关信息 |
| ------------- | ------------------ | ------------ | -------------- |
| 进程标识符PID | 进程当前状态       | 代码段指针   | 通用寄存器值   |
| 用户标识符UID | 进程优先级         | 数据段指针   | 地址寄存器值   |
|               | 代码运行入口地址   | 堆栈段指针   | 控制寄存器值   |
|               | 程序的外存地址     | 文件描述符   | 标志寄存器值   |
|               | 进入内存时间       | 键盘         | 状态字         |
|               | 处理机占用时间     | 鼠标         |                |
|               | 信号量使用         |              |                |
- **进程描述信息**

  - 进程标识符PID：标志各进程，每个进程有唯一标识号
  - 用户标识符UID：进程归属用户，为共享和保护服务

- **进程控制和管理信息**

  - 进程当前状态：描述进程状态，作为处理机分配调度依据
  - 进程优先级：描述进程抢占处理机的优先级

- **资源分配清单**

  说明有关内存地址和虚拟地址状况，所打开文件列表和I/O信息

- **处理机相关信息**

  处理集中各寄存器值<sub>进程切换保存</sub>

**程序段**

被进程调度到CPU执行代码段

**数据段**

进程程序处理的数据

### 进程通信

进程之间信息交换

**共享存储**

进程之间存在一块可**直接访问**的共享空间，通过对共享空间读写进行通信

![](https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/F1E7DC5BA8BF48AE8D8C9132C055A29B/69247)

需要**同步互斥**，必须通过**系统调用**实现

**消息传递**

以**格式化消息**为单位

- 直接通信方式
- 间接通信方式<sub>邮件</sub>

![](https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/17461E55F69F4857B613B82517EC6DBE/69249)

**管道通信**

![](https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/D09E471082B9482181CAD659D941DF79/69251)

连接一个读进程和一个写进程

**提供协调能力：**互斥、同步、确定对方存在

## 线程

基本的CPU执行单元<sub>线程ID、程序计数器、寄存器集合、堆栈</sub>
进程一个实体，被系统独立调度的基本单位

### 线程 & 进程

**调度：**

- 线程是独立调度的基本单位

- 同一进程中线程切换不会引起进程切换

  不同进程中线程切换会引起进程切换

**资源：**

- 进程是拥有资源的基本单位
- 线程不拥有系统资源

**并发性：**均可并发执行

**系统开销：**进程开销远大于线程开销

**地址空间和其他资源：**

- 进程地址空间相互独立
- 同一进程各线程共享资源

**通信：**

- 进程通信需进程同步和互斥辅助
- 线程通信直接读写进程数据段

### 线程属性

- 不拥有系统资源，但每个线程都有一个唯一的标识符和一个线程控制块
- 不同的线程可以执行相同的程序
- 同一进程中各个线程共享该进程资源
- 线程是处理机的独立调度单位，多个线程可以并发执行
- 线程在生命周期内会经历阻塞态、就绪态和运行态等状态变化

### 线程实现方式

**用户级线程ULT：**线程管理所有工作由应用程序完成

**内核级线程KLT：**线程管理所有工作由内核完成

### 多线程模型

**多对一模型：**多个用户线程映射到一个内核线程

- 线程管理在用户空间完成，用户线程对操作系统不可见
- **优点：**线程管理是在用户空间进行的，效率较高
  **缺点：**
  - 线程在使用内核时被阻塞，整个进程都会被阻塞
  - 多个线程不能并行运行在多处理机上

**一对一模型：**每个用户线程映射到内核线程

- **优点：**并发能力较强<sub>当一个线程被阻塞后，允许另一个线程继续执行</sub>
- **缺点：**:每个用户级线程都对应一个内核级线程，创建线程开销较大，影响到应用程序的性能。

**多对多模型：**$n$个用户线程映射到$m$个内核线程

- **特点：**集两者所长

# 处理机调度

### 为什么要处理机调度

进程时常等待I/O输入
若总是处理机等待外部设备，则处理机资源极大浪费
处理机调度可在等待外部设备时，将处理机调度其他资源
提高处理机利用效率

### 调度层次

**作业调度**(高级调度)：外存后备作业分配资源，进入就绪队列

**中级调度**(高级调度)：挂起队列调入内存，进入就绪队列<sub>暂时不用的挂起</sub>

**进程调度**(低级调度)：就绪队列分配给处理机，进入运行态

![](https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/7BBF531D0FF0499F86A89A0B88A510FA/70056)

## 调度时机 & 切换 & 过程

### 调度顺序

1. 请求调度
2. 运行调度程序
3. 进程切换

### 不能进行调度切换情况

- **处理中断过程中**：中断过程是系统工作，不属于进程
- **进程在内核程序临界区**：临界区独占资源
- **原子操作**：加锁、解锁、中断现场保护、恢复等

### 应该调度切换

- 引起调度条件且当前进程无法继续运行（非剥夺调度）
- 中断或自陷处理结束后，若置上请求调度标志，即可立即进行调度切换

## 进程调度方式

**非剥夺调度方式**

- 当一个进程执行时，即使更重要进程进入就绪队列，仍然让进程继续执行直到完成或进入阻塞态，才分配处理机给就绪进程
-  CPU分配给进程，该进程即保持CPU直到终止或等待态。

- **优点**：实现简单、系统开销小，适用于大多数批处理系统
- **缺点**：不能用于分时系统和大多数的实时系统

**剥夺调度方式**

- 当一个进程执行时，若更重要的进程需要处理机，则立即暂停正执行进程，分配处理机给这个更为重要或紧迫的进程
- **优点**：提高系统吞吐率和响应效率

## 调度基本准则

**CPU利用率：**尽可能使CPU利用率最高

**系统吞吐量：**单位时间CPU完成作业数量

**周转时间：**作业提交到作业完成总时间
$$
周转时间=作业完成时间-作业提交时间
$$

$$
带权周转时间=\dfrac{作业周转时间}{作业运行时间}
$$



**等待时间：**进程处于等待状态总和<sub>不影响执行或I/O时间</sub>

**响应时间：**用户提交请求到首次响应时间

## 调度算法

### 先来先服务调度算法FCFS

选择最先进入该队列进程

- 不可剥夺算法
- **优点：**算法简单，对长作业有利，有利于CPU繁忙型作业
- **缺点：**效率低下，对短作业不利，不利于I/O繁忙型作业

### 短作业优先调度算法SJF

选择运行时间最短的作业

- **优点：**平均等待时间最少，平均周转时间最少
- **缺点**
  - 对长作业不利，导致长作业长期不被调度<sub>饥饿</sub>
  - 未考虑紧迫程度
  - 只是根据估计执行时间确定

### 优先级调度算法

选择优先级最高的作业

**参考原则：**

- 系统进程$>$用户进程
- 交互进程$>$非交互进程
- I/O进程$>$计算进程

### 高响应比优先调度算法

$$
响应比R_P=\dfrac{等待时间+要求服务时间}{要求服务时间}
$$

- 平衡FCFS和SJF
- 属于先来先服务
- 对于等待时间足够长，响应比可升高，克服饥饿状态

### 时间片轮转调度算法

以先来先服务原则，但仅运行一个时间片

时间片确定因素：系统响应时间、就绪队列进程、系统处理能力

### 多级反馈队列调度算法

结合时间片轮转调度和优先级调度

![](https://note.youdao.com/yws/public/resource/184d98d8660f6c8c5e0ceb402e6f6258/xmlnote/2048548B0AD345519DEA55DA6B6803AC/70058)

1. 设置多个就绪队列，并赋予不同优先级
2. 优先级越高的队列，时间片越小
3. 进程进入内存后，先置于第1级队列末尾，按FCFS原则调度
4. 若一个时间片无法完成，则转入之后队列
5. 第$n$级队列使用时间片轮转
6. 当$1\sim i-1$级队列均为空时，才调度$i$级队列运行
7. 若$i$级进程运行中，又有较高优先级进程进入$1\sim i-1$队列，抢占处理机

**优点：**

- 终端型作业用户：短作业优先
- 短批处理作业用户：周期时间较短
- 长批处理作业用户：前几个队列得到部分执行，不会长期得不到处理

# 进程同步

协调进程之间制约关系

### 临界资源

一次仅允许一个进程使用的资源，访问必须互斥进行

**访问过程**

- **进入去：**检查是否可进临界区
- **临界区：**访问临界资源代码
- **退出区：**清除临界区访问标志
- **剩余区：**其余代码

```c
do{
    entry section;     // 进入区
    critical section;  // 临界区
    exit section;      // 退出区
    remainder section; // 剩余区
}while(true)
```

### 同步

进程为协调工作次序等待

### 互斥

一个进程使用临界资源，另一个必须等待

**遵循准则**

- **空闲让进：**临界区空闲时，允许一个请求进入临界区
- **忙则等待：**有进程进入临界区时，其他试图进入临界区进程必须等待
- **有限等待：**请求访问的进程应保证在有限时间内进入临界区
- **让权等待：**进程不能访问临界区时，应立即释放处理器

## 临界区互斥实现

### 软件实现方法

**单标志法**

设置公用变量`turn`，作为允许进入临界区进程编号

但若$P_0$离开后$P_1$没有进入打算，`turn=1`恒成立，$P_0$无法再次进入

```c
//P0进程                   //P1进程
while(turn != 0);         while(turn != 1);    // 进入区
critical section;         critical section;    // 临界区
turn = 1;                 turn = 0;            // 退出区
remainder section;        remainder section;   // 剩余区
```

**双标志法先检查**

进程访问前先检查临界资源是否正被访问

设置`flag[i]`表示$P_i$进程是否进入临界区

```c
//Pi进程                   //Pj进程
while(flag[j]);   ①         while(falg[i]);  ②   // 进入区
flag[i] = TRUE;   ③         flag[j] = TURE;  ④   // 进入区
critical section;         critical section;      // 临界区
flag[i] = FALSE;          flag[j] = FALSE        // 退出区
remainder section;        remainder section;     // 剩余区
```

- **优点：**不用交替进入，可连续使用
- **缺点：**$P_i$和$P_j$同时进入临界区，按①②③④顺序执行，会同时进入临界区<sub>检查对方`flag`和切换自己`flag`中间间隔</sub>

**双标志法后检查**

先设置自己标志，再检测对方状态

```c
//Pi进程                   //Pj进程
flag[i] = TRUE;           flag[j] = TURE;    // 进入区
while(flag[j]);           while(falg[i]);    // 进入区
critical section;         critical section;  // 临界区
flag[i] = FALSE;          flag[j] = FALSE;   // 退出区
remainder section;        remainder section; // 剩余区
```

双方进入临界区时，同时发现对方也要进入，造成饥饿现象

**Peterson算法**

先设置标志，再设置turn

同时检测另一个进程标志和不许进入标志

```c
//Pi进程                   //Pj进程
flag[i] = TRUE;turn = j;  flag[j] = TURE;turn = i  // 进入区
while(flag[j]&&turn==j);  while(falg[i]&& turn==i);// 进入区
critical section;         critical section;  // 临界区
flag[i] = FALSE;          flag[j] = FALSE;   // 退出区
remainder section;        remainder section; // 剩余区
```

- 请求资源前，先举起自己的Flag
- 在资源上布置“另一个进程正在使用的标签"turn
- 若**<font color="blue">对方举旗切资源标签不是自己</font>**，等待；否则访问资源
- 访问结束，放旗

### 硬件实现方法

**中断屏蔽方法**

通过禁止一切中断阻止其他进程进入临界区访问

```reStructuredText
.
.
.
关中断;
临界区;
开中断;
.
.
.
```

限制了处理机交替能力，降低执行效率

将关中断权限交予用户不安全

**硬件指令方法**

通过`TextAndSet`原子指令使得执行代码不得中断

```c
boolean TestAndSet(boolean *lock){
    boolean old;
    old = *lock;
    *lock = true;
    return old;
}
```

即临界资源设置共享变量`lock`，`true`表示被占用

实现互斥算法：

```c
while TestAndSet(&lock);
进程临界区代码段;
lock = false;
进程其他代码;
```

自旋锁：通过`xchg`交换访问共享资源

- 初始状态：共享资源区`key=1`

- 原子操作`xchg`：将进程所持`key`与共享`key`互换

  ```c
  int xchg(volatile int *addr, int newval) {
    int result;
    asm volatile ("lock xchg %0, %1"
      : "+m"(*addr), "=a"(result) : "1"(newval));
    return result;
  }
  ```

- 出临界区后，换回所持`key`

```c
int table = YES;

void lock() {
retry:
  int got = xchg(&table, NOPE);
  if (got == NOPE)
    goto retry;
  assert(got == YES);
}

void unlock() {
  xchg(&table, YES)
}
```

## 信号量

**$P$操作**`wait(S)`：请求资源

**$V$操作**`signal(S)`：释放资源

### 整型信号量

`S`表示资源数目

```c
wait(S){  // 请求资源
    while(s <= 0);  // 资源耗尽
    S = S - 1;
}

signal(S){  // 释放资源
    S = S + 1;
}
```

### 记录型信号量

```c
typedef struct{
    int value;  // 整型资源数目
    struct process *L;  // 等待该资源进程链表
}semaphore;

void wait(semaphore S){  // 申请资源
    S.value--;
    if(S.value < 0){  // 资源耗尽
        add this process to S.L;
    }
    block(S.L);  // 自我阻塞，放弃处理机
}

void signal(semaphore){  // 释放资源
    S.value++;  // 释放资源
    if(S.value <= 0){  // 仍有进程被阻塞
        remove a process P from S.L;
        wakeup(P);  // 唤醒进程
    }
}
```

### 信号量实现同步

`S`为$P_1、P_2$公共信号量，$P_2$要用$P_1$语句$x$的结果

该方法亦可实现前驱

```c
semaphore S = 0;  // 初始化信号量
P1(){
    x;
    V(S);  // 告知x已完成
}
P2(){
    P(S);  // 阻塞，检查x是否完成
    y;  //执行y
}
```

### 信号量实现互斥

```c
semaphore S = 1;  // 资源为1
P1(){
    ...
    P(S);  // 准备访问，加锁
    进程P1临界区;
    V(S);  // 访问结束，解锁
    ...
}

P2(){
    ...
    P(S);  // 准备访问，加锁
    进程P2临界区;
    V(S);  // 访问结束，解锁
    ...
}
```

## 管程

共享数据结构实施操作的一组过程

### 管程组成

- 管程名称
- 内部共享结构数据说明
- 数据结构操作过程
- 共享数据初始值

```c
monitor Demo{  // 定义名称
    // 定义数据结构
    init_code(){  // 数据初始值
        S = 5;
    }
    take_away(){  // 申请资源
        对共享数据结构x一系列处理;
        S--;
    }
    give_back(){  // 归还资源
    	对共享数据结构x一系列处理;
        S++;
    }
}
```

- 管程把共享资源操作封装
- 每次仅允许一个进程进入管程，实现进程互斥

### 条件变量

阻塞原因定义`condition`

每个条件变量保存一个等待队列，记录应该条件变量阻塞进程

```C
monitor Demo{
    共享数据结构 S;
    condition x;  // 条件变量x
    init_code(){...}
    take_away(){
        if(S <= 0) x.wait();  // 资源不够，在x上阻塞等待
        资源足够，分配资源，做一系列处理
    }
    give_back(){
        归还资源，做一系列处理;
        if(有进程等待) x.signal;  // 唤醒阻塞进程
    }
}
```

**条件变量 & 信号量**

- 相似点：```wait/signal```类似于```P/V```
- 不同点：条件变量没有值，仅实现排队等待功能；信号量有值，反映剩余资源数

需要等待条件满足时

```c
mutex_lock(&mutex);
while (!cond) {
  wait(&cv, &mutex);
}
assert(cond);
// ...
// 互斥锁保证了在此期间条件 cond 总是成立
// ...
mutex_unlock(&mutex);
```

其他线程条件可能被满足时

```c
broadcast(&cv);
```



## 同步问题

### 生产者-消费者问题
同步互斥问题

**问题描述**

一组生产者和一组消费者共享一个初始为空、大小为$n$的缓冲区，
只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待
只有缓冲区不空时，消费者才能从中取出消息，否则必须等待
缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。
```c
semaphore mutex = 1;  // 临界区互斥信号量
semaphore empty = n;  // 空闲缓冲区
semaphore full = 0;  // 缓冲区初始化为空
producer(){  // 生产者进程
    while(1){
        produce a item in nextp;  // 生产数据
        P(empty);  // 获取缓冲区单元
        P(mutex);  // 互斥，进入临界区
        add nextp to buffer;  // 数据放入缓冲区
        V(mutex);  // 离开临界区，释放互斥
        V(full);  // 释放缓冲区
    }
    
consumer(){  // 消费者进程
    while(1){
        P(full);  // 获取缓冲区单元
        P(mutex);  // 互斥，进入临界区
        remove an item from buffer;  // 缓冲区取出数据
        V(mutex);  // 离开临界区，释放互斥
        V(empty);  // 空缓冲区++
        consume the item;  // 消费数据
    }
}
}
```
### 读者-写者问题

**问题描述：**
读者和写者两组并发共享一个文件
允许多个读者可以同时对文件执行读操作
只允许一个写者往文件中写信息
任一写者在完成写操作之前不允许其他读者或写着工作
写者执行写操作前，应让已有的读者和写者全部退出。

```c
int count = 0;  // 当前读者数量
semaphore mutex = 1;  // 更新count互斥
semaphore rw = 1;  // 保证读者写者互斥访问

write(){  // 写者进程
	while(1){
		P(rw);  // 互斥访问共享文件
		writing;  // 写入
		V(rw);  // 释放共享文件
	}
}

reader(){  // 读者进程
	while(1){
		P(mutex);  // 互斥访问count变量
		if(count == 0)  // 第一个读进程读共享文件
			P(rw);  // 阻止写进程写
		count++;  // 读者计数器++
		V(mutex);  // 释放互斥变量
		reading; // 读取
		P(mutex);  // 互斥访问count变量
		count--;
		if(count == 0)  // 当最后一个读进程读完共享文件
			V(rw);  // 允许写进程
		V(mutex);  // 释放互斥变量
	}
}
```

### 哲学家进餐问题

**问题描述：**

一张桌坐着5名哲学家
每两名哲学家之间桌上摆一根筷子
当哲学家饥饿时，才试图拿起左、右两根筷子
若筷子已在他人手上，则需等待
只有当哲学家同时拿起两根筷子才可进餐

```c
semaphore chopsticks[5] = {1,1,1,1,1};  // 初始化信号量
semaphore mutex = 1;  // 设置取筷子信号量
Pi(){  // i号哲学家进程
    P(mutex);  // 取筷子前获得互斥
    P(chopsticks[i]);  // 取左筷子
    P(chopsticks[(i + 1) & 5]);  // 取右边筷子
    V(mutex);  // 释放取筷子信号量
    eat;  // 进餐
    V(chopsticks[i]);  // 放回左边筷子
    V(chopsticks[(i + 1) & 5]);  // 放回右边筷子
    think;  // 继续思考
}while(1)
```

当一名哲学家左右筷子均可用，才允许抓起筷子

- 避免贪心，多考虑一步

万能方法

```c
mutex_lock(&mutex);
while (!(avail[lhs] && avail[rhs])) {
  wait(&cv, &mutex);
}
avail[lhs] = avail[rhs] = false;
mutex_unlock(&mutex);

mutex_lock(&mutex);
avail[lhs] = avail[rhs] = true;
broadcast(&cv);
mutex_unlock(&mutex);
```

管理者

```c
void Tphilosopher(int id) {
  send_request(id, EAT);
  P(allowed[id]); // waiter 会把叉子递给哲学家
  philosopher_eat();
  send_request(id, DONE);
}

void Twaiter() {
  while (1) {
    (id, status) = receive_request();
    if (status == EAT) { ... }
    if (status == DONE) { ... }
  }
}
```



### 吸烟者问题

**问题描述**

有三个抽烟者和一个供应者进程
每个抽烟者不停卷烟并抽掉
但要卷起并抽掉一支烟，抽烟者需要有烟草、纸、胶水
三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水
供应者进程无限地提供三种材料
供应者每次将两种材料放到桌子上
拥有剩下那种材料的抽烟者卷一根烟并抽掉它
并给供应者一个信号告诉已完成
此时供应者就会将另外两种材料放到桌上
如此重复（让三个抽烟者轮流地抽烟)

```c
int num = 0;  // 存储随机数
semaphore offer1 = 0;  // 定义烟草和纸组合
semaphore offer2 = 0;  // 定义烟草和胶水组合
semaphore offer3 = 0;  // 定义纸和胶水组合
process finish = 0;  // 表示抽烟是否完成
process P1(){  // 供应者
    while(1){
        num++;
        num = num % 3;
        if(num == 0)
            V(offer1);  // 提供烟草和纸
        else if(num == 1)
            V(offer2);  // 提供烟草和胶水
        else
            V(offer3);  // 提供纸和胶水
        任意两种材料放在桌上;
        P(finish);
    }
    process P2(){  // 拥有烟草者
        while(1){
            P(offer3);  
            取走纸和胶水，卷烟;
            V(finish);
        }
    }
    process P3(){  // 拥有纸者
        while(1){
            P(offer2);
            取走烟草和胶水，卷烟;
            V(finish);
        }
    }
    process P4(){  // 拥有胶水者
        while(1){
            P(offer1);
            取走烟草和纸，卷烟;
            V(finish);
        }
    }
}
```

# 死锁

多个进程竞争资源造成互相等待

### 死锁原因

- 系统资源竞争
- 进程推进顺序非法
- 必要条件：互斥、不剥夺、请求并保持、循环等待

## 死锁处理策略

**死锁预防：**设置限制条件，破坏必要条件

**避免死锁：**动态分配时，防止系统进入不安全状态

**死锁检测及解除：**通过系统检测及时检测，采取某种措施

|              | 资源分配策略             | 各种可能模式                             | 优点                                     | 缺点                                                         |
| ------------ | ------------------------ | ---------------------------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| **死锁预防** | 保守，宁可资源闲置       | 一次请求所有资源，资源剥夺，资源按序分配 | 适用突发处理的进程，不必进行剥夺         | 效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源 |
| **死锁避免** | 是“预防”和“检测”的折中   | 寻求可能的安全允许顺序                   | 不必进行剥夺                             | 必须知道奖来资源需求；进程不能被长时间阻塞                   |
| **死锁检测** | 宽松，只要允许就分配资源 | 定期检查死锁是否已经发生                 | 不延长进程初始化时间，允许对死锁现场处理 | 通过剥夺解除死锁，造成损失                                   |

## 死锁预防

**破坏互斥条件：**不可行

**破坏不剥夺条件：**

释放已保持的所有资源

常用于状态易于保存和恢复的资源

**破坏请求并保持条件：**

运行前一次申请完全部资源

实现简单，但资源严重浪费

易导致饥饿现象

**破坏循环等待条件：**

采用顺序资源分配法

**<font color="red">给系统中资源编号，规定每个进程必须按编号递增顺序请求资源</font>**

优点：编号必须相对稳定

缺点：造成资源的浪费

## 死锁避免

### 系统安全状态

系统按照某种进程推进顺序为每个进程$P_i$分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成

### 银行家算法

**数据结构描述**

可利用资源向量`Available`：含$m$个元素的数组，其中每个元素代表一类可用的资源数目(`Available[j]=K`表示系统现有$R_j$类资源$K$个)

最大需求矩阵$Max_{n\times m}$：行代表进程；列代表某类资源

分配矩阵$Allocation_{m\times n}$：每类资源当前分配给每个进程的资源数

需求举证$Need_{m\times n}$：每个进程接下来最多还需要多少资源

**算法描述**

设$Request_i[j]=K$即进程$P_i$需要$j$类资源$K$个

当$P_i$发出资源请求后，按下述步骤检查

1. $Request_i[j]\le Need[i,j]$，转向②；否则认为出错<sub>所需资源超过最大值</sub>

2. $Request_i[j]\le Available[j]$，转向步骤③；$P_i$须等待<sub>尚无足够资源</sub>

3. 系统试探将资源分配给进程$P_i$，并修改数据结构数值

   $Available=Available-Request_i;\\Allocation[i,j]=Allocation[i,j]+Request_i[j];\\Need[i,j]=Need[i,j]-Request_i[j]$

4. 系统执行安全性算法，判断是否安全
   安全则正式分配资源给进程$P_i$
   否则将本次试探作废

**安全性算法**

工作向量$Work$：系统中剩余可用资源数，初始$Work=Available$

1. 初始时安全序列为空

2. 从$Need$找到符合条件的行：

   该行对应进程不在安全序列中，且该行小于等于$Work$向量

   找到把对应进程加入安全序列

   找不到执行步骤④

3. 进程$P_i$进入安全序列后可顺利执行，直到完成，并释放资源

   $Work=Work+Allocation[i]$

4. 若此时安全序列中已有所有进程，则系统处于安全状态

## 死锁检测 & 解除

### 死锁定理

$S$死锁$\Leftrightarrow$$S$资源分配图不可完全简化

### 死锁解除

- **资源剥夺法：**挂起某些死锁进程，并抢占其资源
- **撤销进程法：**强制撤销部分死锁进程并剥夺资源
- **进程回退法：**让进程回退到足以回避死锁地步